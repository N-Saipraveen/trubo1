/**
 * SQLite-Specific SQL Generator
 * Handles SQLite dialect normalization and conversions
 */

import { SqlSchema, SqlTable, SqlColumn } from '../extract/sqlExtractor';
import logger from '../../utils/logger';

export interface SQLiteLoadOptions {
  includeDropStatements?: boolean;
  includeIfNotExists?: boolean;
  enableForeignKeys?: boolean;
  strictMode?: boolean;
}

/**
 * MySQL to SQLite type mapping
 */
const mysqlToSQLiteTypes: Record<string, string> = {
  // Integers
  'TINYINT': 'INTEGER',
  'SMALLINT': 'INTEGER',
  'MEDIUMINT': 'INTEGER',
  'INT': 'INTEGER',
  'INTEGER': 'INTEGER',
  'BIGINT': 'INTEGER',

  // Floating point
  'FLOAT': 'REAL',
  'DOUBLE': 'REAL',
  'DECIMAL': 'REAL',
  'NUMERIC': 'REAL',

  // Strings
  'CHAR': 'TEXT',
  'VARCHAR': 'TEXT',
  'TINYTEXT': 'TEXT',
  'TEXT': 'TEXT',
  'MEDIUMTEXT': 'TEXT',
  'LONGTEXT': 'TEXT',

  // Binary
  'BLOB': 'BLOB',
  'TINYBLOB': 'BLOB',
  'MEDIUMBLOB': 'BLOB',
  'LONGBLOB': 'BLOB',
  'BINARY': 'BLOB',
  'VARBINARY': 'BLOB',

  // Date/Time
  'DATE': 'TEXT',
  'DATETIME': 'TEXT',
  'TIMESTAMP': 'TEXT',
  'TIME': 'TEXT',
  'YEAR': 'INTEGER',

  // Boolean
  'BOOLEAN': 'INTEGER',
  'BOOL': 'INTEGER',

  // JSON (stored as TEXT in SQLite)
  'JSON': 'TEXT',
};

/**
 * Generate SQLite DDL from schema
 */
export function loadSQLiteSchema(schema: SqlSchema, options: SQLiteLoadOptions = {}): string {
  const {
    includeDropStatements = false,
    includeIfNotExists = true,
    enableForeignKeys = true,
    strictMode = false,
  } = options;

  const statements: string[] = [];

  // SQLite pragma statements
  statements.push('-- SQLite Schema Generated by TurboDbx');
  statements.push('-- Generated at: ' + new Date().toISOString());
  statements.push('');

  if (enableForeignKeys) {
    statements.push('-- Enable foreign key constraints');
    statements.push('PRAGMA foreign_keys = ON;');
    statements.push('');
  }

  // Generate CREATE TABLE statements
  for (const table of schema.tables) {
    if (includeDropStatements) {
      statements.push(`DROP TABLE IF EXISTS ${table.name};`);
      statements.push('');
    }

    statements.push(generateSQLiteCreateTable(table, includeIfNotExists, strictMode));
    statements.push('');
  }

  // Generate indexes
  for (const table of schema.tables) {
    const indexStatements = generateSQLiteIndexes(table);
    if (indexStatements.length > 0) {
      statements.push(...indexStatements);
      statements.push('');
    }
  }

  logger.info(`Generated SQLite DDL with ${schema.tables.length} tables`);

  return statements.join('\n');
}

/**
 * Generate SQLite CREATE TABLE statement
 */
function generateSQLiteCreateTable(table: SqlTable, includeIfNotExists: boolean, strictMode: boolean): string {
  const lines: string[] = [];
  const ifNotExists = includeIfNotExists ? 'IF NOT EXISTS ' : '';

  lines.push(`CREATE TABLE ${ifNotExists}${table.name} (`);

  // Columns
  const columnDefs: string[] = [];

  for (const column of table.columns) {
    const colDef = generateSQLiteColumn(column, table.primaryKey || []);
    columnDefs.push(`  ${colDef}`);
  }

  // Add column definitions
  lines.push(columnDefs.join(',\n'));

  // Primary key constraint (if composite)
  if (table.primaryKey && table.primaryKey.length > 1) {
    lines.push(`,\n  PRIMARY KEY (${table.primaryKey.join(', ')})`);
  }

  // Foreign keys
  for (const fk of table.foreignKeys) {
    const fkDef = `  FOREIGN KEY (${fk.columnName}) REFERENCES ${fk.referencedTable}(${fk.referencedColumn})`;
    const actions: string[] = [];

    if (fk.onDelete) {
      actions.push(`ON DELETE ${fk.onDelete}`);
    }
    if (fk.onUpdate) {
      actions.push(`ON UPDATE ${fk.onUpdate}`);
    }

    lines.push(`,\n${fkDef}${actions.length > 0 ? ' ' + actions.join(' ') : ''}`);
  }

  // Unique constraints
  for (const constraint of table.constraints) {
    if (constraint.type === 'UNIQUE') {
      // Extract column names from constraint definition
      const match = constraint.definition.match(/UNIQUE\s*\(([^)]+)\)/i);
      if (match) {
        lines.push(`,\n  UNIQUE (${match[1]})`);
      }
    }
  }

  // Check constraints (for ENUM conversions)
  for (const constraint of table.constraints) {
    if (constraint.type === 'CHECK') {
      lines.push(`,\n  ${constraint.definition}`);
    }
  }

  lines.push(')');

  // Add STRICT mode if requested (SQLite 3.37.0+)
  if (strictMode) {
    lines.push(' STRICT');
  }

  lines.push(';');

  return lines.join('');
}

/**
 * Generate SQLite column definition
 */
function generateSQLiteColumn(column: SqlColumn, primaryKeys: string[]): string {
  // Normalize type to SQLite type
  const baseType = column.type.replace(/\([^)]*\)/g, '').trim().toUpperCase();
  const sqliteType = mysqlToSQLiteTypes[baseType] || 'TEXT';

  let def = `${column.name} ${sqliteType}`;

  // PRIMARY KEY (for single-column primary keys)
  const isPrimaryKey = primaryKeys.length === 1 && primaryKeys.includes(column.name);
  if (isPrimaryKey) {
    def += ' PRIMARY KEY';

    // AUTOINCREMENT (only for INTEGER PRIMARY KEY)
    if (column.autoIncrement && sqliteType === 'INTEGER') {
      def += ' AUTOINCREMENT';
    }
  }

  // NOT NULL
  if (!column.nullable && !isPrimaryKey) {
    def += ' NOT NULL';
  }

  // DEFAULT value
  if (column.defaultValue !== undefined) {
    if (typeof column.defaultValue === 'string') {
      // Check if it's a function or keyword
      const upper = column.defaultValue.toUpperCase();
      if (upper === 'CURRENT_TIMESTAMP' || upper === 'NULL') {
        def += ` DEFAULT ${upper}`;
      } else {
        def += ` DEFAULT '${column.defaultValue}'`;
      }
    } else if (typeof column.defaultValue === 'boolean') {
      def += ` DEFAULT ${column.defaultValue ? 1 : 0}`;
    } else {
      def += ` DEFAULT ${column.defaultValue}`;
    }
  }

  // UNIQUE
  if (column.unique && !isPrimaryKey) {
    def += ' UNIQUE';
  }

  return def;
}

/**
 * Generate SQLite indexes
 */
function generateSQLiteIndexes(table: SqlTable): string[] {
  const statements: string[] = [];

  // Create indexes for foreign keys (recommended for performance)
  for (const fk of table.foreignKeys) {
    const indexName = `idx_${table.name}_${fk.columnName}`;
    statements.push(`CREATE INDEX ${indexName} ON ${table.name} (${fk.columnName});`);
  }

  // Create other indexes
  for (const index of table.indexes) {
    const unique = index.unique ? 'UNIQUE ' : '';
    const indexName = index.name || `idx_${table.name}_${index.columns.join('_')}`;
    statements.push(`CREATE ${unique}INDEX ${indexName} ON ${table.name} (${index.columns.join(', ')});`);
  }

  return statements;
}

/**
 * Convert MySQL ENUM to SQLite CHECK constraint
 */
export function convertEnumToCheck(columnName: string, enumValues: string[]): string {
  const quotedValues = enumValues.map(v => `'${v}'`).join(', ');
  return `CHECK (${columnName} IN (${quotedValues}))`;
}

/**
 * Remove MySQL-specific table options
 */
export function stripMySQLOptions(sql: string): string {
  // Remove ENGINE=...
  sql = sql.replace(/ENGINE\s*=\s*\w+/gi, '');

  // Remove DEFAULT CHARSET=...
  sql = sql.replace(/DEFAULT\s+CHARSET\s*=\s*\w+/gi, '');

  // Remove COLLATE=...
  sql = sql.replace(/COLLATE\s*=\s*\w+/gi, '');

  // Remove AUTO_INCREMENT=...
  sql = sql.replace(/AUTO_INCREMENT\s*=\s*\d+/gi, '');

  // Remove COMMENT=...
  sql = sql.replace(/COMMENT\s*=\s*'[^']*'/gi, '');

  // Remove ROW_FORMAT=...
  sql = sql.replace(/ROW_FORMAT\s*=\s*\w+/gi, '');

  // Clean up extra whitespace and commas
  sql = sql.replace(/,\s*\)/g, ')');
  sql = sql.replace(/\s+/g, ' ');

  return sql.trim();
}
