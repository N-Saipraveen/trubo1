/**
 * NoSQL Schema Loader
 * Generates MongoDB schemas and validation rules
 */

import { NoSqlSchema, NoSqlCollection, NoSqlField } from '../extract/nosqlExtractor';
import logger from '../../utils/logger';

export interface NoSqlLoadOptions {
  format?: 'json' | 'yaml' | 'mongoose' | 'validator';
  includeValidation?: boolean;
  includeIndexes?: boolean;
  includeComments?: boolean;
  indentation?: number;
}

/**
 * Load NoSQL schema and generate output
 */
export function loadNoSqlSchema(schema: NoSqlSchema, options: NoSqlLoadOptions = {}): string {
  const {
    format = 'json',
    includeValidation = true,
    includeIndexes = true,
    includeComments = true,
  } = options;

  switch (format) {
    case 'json':
      return generateJsonSchema(schema, options);
    case 'yaml':
      return generateYamlSchema(schema, options);
    case 'mongoose':
      return generateMongooseSchemas(schema, options);
    case 'validator':
      return generateValidators(schema, options);
    default:
      return generateJsonSchema(schema, options);
  }
}

/**
 * Generate JSON schema
 */
function generateJsonSchema(schema: NoSqlSchema, options: NoSqlLoadOptions): string {
  const output: any = {
    type: 'mongodb',
    version: '1.0',
    collections: [],
  };

  for (const collection of schema.collections) {
    const collectionDef: any = {
      name: collection.name,
      fields: collection.fields.map(fieldToJson),
    };

    if (options.includeIndexes && collection.indexes && collection.indexes.length > 0) {
      collectionDef.indexes = collection.indexes;
    }

    if (options.includeValidation && collection.validator) {
      collectionDef.validator = collection.validator;
    }

    output.collections.push(collectionDef);
  }

  if (schema.relationships && schema.relationships.length > 0) {
    output.relationships = schema.relationships;
  }

  logger.info(`Generated JSON schema with ${schema.collections.length} collections`);

  return JSON.stringify(output, null, options.indentation || 2);
}

/**
 * Generate YAML schema
 */
function generateYamlSchema(schema: NoSqlSchema, options: NoSqlLoadOptions): string {
  const lines: string[] = [];

  if (options.includeComments) {
    lines.push('# Generated by TurboDbx');
    lines.push(`# Generated at: ${new Date().toISOString()}`);
    lines.push('');
  }

  lines.push('type: mongodb');
  lines.push('version: "1.0"');
  lines.push('collections:');

  for (const collection of schema.collections) {
    lines.push(`  - name: ${collection.name}`);
    lines.push('    fields:');

    for (const field of collection.fields) {
      lines.push(`      - name: ${field.name}`);
      lines.push(`        type: ${field.type}`);

      if (field.required) {
        lines.push(`        required: true`);
      }
      if (field.unique) {
        lines.push(`        unique: true`);
      }
      if (field.ref) {
        lines.push(`        ref: ${field.ref}`);
      }
      if (field.default !== undefined) {
        lines.push(`        default: ${JSON.stringify(field.default)}`);
      }
    }

    if (options.includeIndexes && collection.indexes && collection.indexes.length > 0) {
      lines.push('    indexes:');
      for (const index of collection.indexes) {
        lines.push(`      - fields: ${JSON.stringify(index.fields)}`);
        if (index.unique) {
          lines.push(`        unique: true`);
        }
      }
    }
  }

  if (schema.relationships && schema.relationships.length > 0) {
    lines.push('relationships:');
    for (const rel of schema.relationships) {
      lines.push(`  - from: ${rel.from}`);
      lines.push(`    to: ${rel.to}`);
      lines.push(`    type: ${rel.type}`);
    }
  }

  return lines.join('\n');
}

/**
 * Generate Mongoose schemas (JavaScript/TypeScript)
 */
function generateMongooseSchemas(schema: NoSqlSchema, options: NoSqlLoadOptions): string {
  const lines: string[] = [];

  if (options.includeComments) {
    lines.push('// Generated by TurboDbx');
    lines.push(`// Generated at: ${new Date().toISOString()}`);
    lines.push('');
  }

  lines.push("import mongoose from 'mongoose';");
  lines.push('');

  for (const collection of schema.collections) {
    lines.push(`// ${collection.name} Schema`);
    lines.push(`const ${capitalize(collection.name)}Schema = new mongoose.Schema({`);

    for (const field of collection.fields) {
      if (field.name === '_id') continue; // Skip _id, MongoDB adds it automatically

      const fieldDef = fieldToMongoose(field);
      lines.push(`  ${field.name}: ${fieldDef},`);
    }

    lines.push('}, {');
    lines.push('  timestamps: true, // Adds createdAt and updatedAt');
    lines.push('});');
    lines.push('');

    // Add indexes
    if (options.includeIndexes && collection.indexes && collection.indexes.length > 0) {
      for (const index of collection.indexes) {
        const fieldsStr = JSON.stringify(index.fields);
        const optionsStr = index.unique ? ', { unique: true }' : '';
        lines.push(`${capitalize(collection.name)}Schema.index(${fieldsStr}${optionsStr});`);
      }
      lines.push('');
    }

    // Export model
    lines.push(`export const ${capitalize(collection.name)} = mongoose.model('${capitalize(collection.name)}', ${capitalize(collection.name)}Schema);`);
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate MongoDB validators
 */
function generateValidators(schema: NoSqlSchema, options: NoSqlLoadOptions): string {
  const validators: any = {};

  for (const collection of schema.collections) {
    validators[collection.name] = {
      validator: {
        $jsonSchema: collectionToJsonSchema(collection),
      },
      validationLevel: 'strict',
      validationAction: 'error',
    };
  }

  return JSON.stringify(validators, null, options.indentation || 2);
}

/**
 * Convert field to JSON format
 */
function fieldToJson(field: NoSqlField): any {
  const obj: any = {
    name: field.name,
    type: field.type,
  };

  if (field.required) obj.required = true;
  if (field.unique) obj.unique = true;
  if (field.ref) obj.ref = field.ref;
  if (field.default !== undefined) obj.default = field.default;
  if (field.enum) obj.enum = field.enum;

  return obj;
}

/**
 * Convert field to Mongoose field definition
 */
function fieldToMongoose(field: NoSqlField): string {
  if (field.ref) {
    // Reference field
    return `{ type: mongoose.Schema.Types.ObjectId, ref: '${capitalize(field.ref)}'${field.required ? ', required: true' : ''} }`;
  }

  const typeMap: Record<string, string> = {
    string: 'String',
    number: 'Number',
    boolean: 'Boolean',
    date: 'Date',
    objectId: 'mongoose.Schema.Types.ObjectId',
    array: 'Array',
    object: 'Object',
    decimal: 'mongoose.Schema.Types.Decimal128',
    binData: 'Buffer',
  };

  const mongooseType = typeMap[field.type] || 'String';

  const parts: string[] = [`type: ${mongooseType}`];

  if (field.required) parts.push('required: true');
  if (field.unique) parts.push('unique: true');
  if (field.default !== undefined) {
    parts.push(`default: ${JSON.stringify(field.default)}`);
  }
  if (field.enum) {
    parts.push(`enum: ${JSON.stringify(field.enum)}`);
  }

  return `{ ${parts.join(', ')} }`;
}

/**
 * Convert collection to JSON Schema format
 */
function collectionToJsonSchema(collection: NoSqlCollection): any {
  const properties: any = {};
  const required: string[] = [];

  for (const field of collection.fields) {
    properties[field.name] = fieldToJsonSchemaType(field);

    if (field.required) {
      required.push(field.name);
    }
  }

  return {
    bsonType: 'object',
    required,
    properties,
  };
}

/**
 * Convert field to JSON Schema type
 */
function fieldToJsonSchemaType(field: NoSqlField): any {
  const typeMap: Record<string, string> = {
    string: 'string',
    number: 'number',
    boolean: 'bool',
    date: 'date',
    objectId: 'objectId',
    array: 'array',
    object: 'object',
    decimal: 'decimal',
    binData: 'binData',
  };

  const bsonType = typeMap[field.type] || 'string';

  const schema: any = { bsonType };

  if (field.enum) {
    schema.enum = field.enum;
  }

  return schema;
}

/**
 * Capitalize first letter
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
