/**
 * SQL Schema Loader
 * Generates SQL DDL statements from schema
 */

import { SqlSchema, SqlTable, SqlColumn, SqlForeignKey } from '../extract/sqlExtractor';
import logger from '../../utils/logger';

export interface SqlLoadOptions {
  dialect?: 'mysql' | 'postgresql' | 'sqlite';
  includeDropStatements?: boolean;
  includeIfNotExists?: boolean;
  includeComments?: boolean;
  indentation?: string;
}

/**
 * Load SQL schema and generate DDL
 */
export function loadSqlSchema(schema: SqlSchema, options: SqlLoadOptions = {}): string {
  const {
    dialect = 'postgresql',
    includeDropStatements = false,
    includeIfNotExists = true,
    includeComments = true,
    indentation = '  ',
  } = options;

  const statements: string[] = [];

  if (includeComments) {
    statements.push('-- Generated by TurboDbx');
    statements.push(`-- Dialect: ${dialect}`);
    statements.push(`-- Generated at: ${new Date().toISOString()}`);
    statements.push('');
  }

  // Generate CREATE TABLE statements
  for (const table of schema.tables) {
    if (includeDropStatements) {
      statements.push(generateDropTable(table.name, dialect));
      statements.push('');
    }

    statements.push(generateCreateTable(table, dialect, includeIfNotExists, indentation));
    statements.push('');
  }

  logger.info(`Generated SQL DDL with ${schema.tables.length} tables`);

  return statements.join('\n');
}

/**
 * Generate DROP TABLE statement
 */
function generateDropTable(tableName: string, dialect: string): string {
  if (dialect === 'sqlite') {
    return `DROP TABLE IF EXISTS ${tableName};`;
  }
  return `DROP TABLE IF EXISTS ${tableName} CASCADE;`;
}

/**
 * Generate CREATE TABLE statement
 */
function generateCreateTable(
  table: SqlTable,
  dialect: string,
  includeIfNotExists: boolean,
  indentation: string
): string {
  const lines: string[] = [];

  // CREATE TABLE
  const ifNotExists = includeIfNotExists ? 'IF NOT EXISTS ' : '';
  lines.push(`CREATE TABLE ${ifNotExists}${table.name} (`);

  // Columns
  const columnDefs = table.columns.map(col => generateColumnDefinition(col, dialect, indentation));
  lines.push(columnDefs.join(',\n'));

  // Primary Key
  if (table.primaryKey && table.primaryKey.length > 0) {
    lines.push(`,\n${indentation}PRIMARY KEY (${table.primaryKey.join(', ')})`);
  }

  // Foreign Keys
  for (const fk of table.foreignKeys) {
    lines.push(`,\n${generateForeignKeyDefinition(fk, indentation)}`);
  }

  // Unique Constraints
  for (const constraint of table.constraints) {
    if (constraint.type === 'UNIQUE') {
      lines.push(`,\n${indentation}${constraint.definition}`);
    }
  }

  lines.push(');');

  // Indexes
  for (const index of table.indexes) {
    lines.push('');
    lines.push(generateIndexDefinition(table.name, index, dialect));
  }

  return lines.join('');
}

/**
 * Generate column definition
 */
function generateColumnDefinition(column: SqlColumn, dialect: string, indentation: string): string {
  let def = `${indentation}${column.name} ${column.type}`;

  // NOT NULL
  if (!column.nullable) {
    def += ' NOT NULL';
  }

  // AUTO INCREMENT
  if (column.autoIncrement) {
    if (dialect === 'postgresql') {
      // PostgreSQL uses SERIAL
      def = `${indentation}${column.name} SERIAL NOT NULL`;
    } else if (dialect === 'mysql') {
      def += ' AUTO_INCREMENT';
    } else {
      // SQLite uses AUTOINCREMENT with INTEGER PRIMARY KEY
      def += ' AUTOINCREMENT';
    }
  }

  // DEFAULT
  if (column.defaultValue !== undefined) {
    if (typeof column.defaultValue === 'string') {
      def += ` DEFAULT '${column.defaultValue}'`;
    } else {
      def += ` DEFAULT ${column.defaultValue}`;
    }
  }

  // UNIQUE
  if (column.unique) {
    def += ' UNIQUE';
  }

  // COMMENT
  if (column.comment && dialect !== 'sqlite') {
    def += ` COMMENT '${column.comment}'`;
  }

  return def;
}

/**
 * Generate foreign key definition
 */
function generateForeignKeyDefinition(fk: SqlForeignKey, indentation: string): string {
  let def = `${indentation}FOREIGN KEY (${fk.columnName}) REFERENCES ${fk.referencedTable}(${fk.referencedColumn})`;

  if (fk.onDelete) {
    def += ` ON DELETE ${fk.onDelete}`;
  }

  if (fk.onUpdate) {
    def += ` ON UPDATE ${fk.onUpdate}`;
  }

  return def;
}

/**
 * Generate index definition
 */
function generateIndexDefinition(tableName: string, index: any, dialect: string): string {
  const unique = index.unique ? 'UNIQUE ' : '';
  const indexName = index.name || `idx_${tableName}_${index.columns.join('_')}`;

  return `CREATE ${unique}INDEX ${indexName} ON ${tableName} (${index.columns.join(', ')});`;
}

/**
 * Generate ALTER TABLE statements for modifications
 */
export function generateAlterStatements(
  tableName: string,
  modifications: Array<{
    type: 'ADD_COLUMN' | 'DROP_COLUMN' | 'ADD_CONSTRAINT' | 'DROP_CONSTRAINT';
    definition: string;
  }>,
  dialect: string = 'postgresql'
): string[] {
  const statements: string[] = [];

  for (const mod of modifications) {
    switch (mod.type) {
      case 'ADD_COLUMN':
        statements.push(`ALTER TABLE ${tableName} ADD COLUMN ${mod.definition};`);
        break;
      case 'DROP_COLUMN':
        statements.push(`ALTER TABLE ${tableName} DROP COLUMN ${mod.definition};`);
        break;
      case 'ADD_CONSTRAINT':
        statements.push(`ALTER TABLE ${tableName} ADD ${mod.definition};`);
        break;
      case 'DROP_CONSTRAINT':
        statements.push(`ALTER TABLE ${tableName} DROP CONSTRAINT ${mod.definition};`);
        break;
    }
  }

  return statements;
}
