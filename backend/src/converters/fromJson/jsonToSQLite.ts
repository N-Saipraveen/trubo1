/**
 * Phase 2: Convert standardized JSON schema to SQLite DDL
 */

import { StandardizedSchema, Table, Column, ForeignKey } from '../../schema_parser/types';
import { SQLiteOptions } from './types';
import logger from '../../utils/logger';

/**
 * Convert standardized JSON schema to SQLite DDL
 */
export function jsonToSQLite(schema: StandardizedSchema, options: SQLiteOptions = {}): string {
  const {
    includeDropStatements = false,
    includeIfNotExists = true,
    indentation = '  ',
    includeComments = true,
    enableForeignKeys = true,
    strictMode = false,
  } = options;

  logger.info('Converting standardized JSON to SQLite DDL');

  const statements: string[] = [];

  // Header
  if (includeComments) {
    statements.push('-- SQLite Schema Generated by TurboDbx');
    statements.push(`-- Source: ${schema.metadata.sourceType}`);
    statements.push(`-- Generated: ${new Date().toISOString()}`);
    statements.push('');
  }

  // PRAGMA
  if (enableForeignKeys) {
    statements.push('PRAGMA foreign_keys = ON;');
    statements.push('');
  }

  // Generate CREATE TABLE statements
  for (const table of schema.tables) {
    if (includeDropStatements) {
      statements.push(`DROP TABLE IF EXISTS ${table.name};`);
      statements.push('');
    }

    statements.push(generateSQLiteCreateTable(table, {
      includeIfNotExists,
      indentation,
      strictMode,
    }));
    statements.push('');
  }

  // Generate indexes
  for (const table of schema.tables) {
    const indexStatements = generateSQLiteIndexes(table);
    if (indexStatements.length > 0) {
      statements.push(...indexStatements);
      statements.push('');
    }
  }

  logger.info(`Generated SQLite DDL with ${schema.tables.length} tables`);

  return statements.join('\n');
}

/**
 * Generate SQLite CREATE TABLE statement
 */
function generateSQLiteCreateTable(
  table: Table,
  options: {
    includeIfNotExists: boolean;
    indentation: string;
    strictMode: boolean;
  }
): string {
  const { includeIfNotExists, indentation, strictMode } = options;
  const lines: string[] = [];

  // CREATE TABLE
  const ifNotExists = includeIfNotExists ? 'IF NOT EXISTS ' : '';
  lines.push(`CREATE TABLE ${ifNotExists}${table.name} (`);

  // Columns
  const columnDefs = table.columns.map(col => generateSQLiteColumn(col, indentation, table.primaryKey));
  lines.push(columnDefs.join(',\n'));

  // Primary Key (composite)
  if (table.primaryKey && table.primaryKey.columns.length > 1) {
    const pkCols = table.primaryKey.columns.join(', ');
    lines.push(`,\n${indentation}PRIMARY KEY (${pkCols})`);
  }

  // Foreign Keys
  for (const fk of table.foreignKeys) {
    lines.push(`,\n${generateSQLiteForeignKey(fk, indentation)}`);
  }

  // Check constraints (from ENUM conversions)
  for (const column of table.columns) {
    if (column.enum && column.enum.length > 0) {
      const values = column.enum.map(v => `'${v}'`).join(', ');
      lines.push(`,\n${indentation}CHECK (${column.name} IN (${values}))`);
    }
  }

  lines.push('\n)');

  if (strictMode) {
    lines.push(' STRICT');
  }

  lines.push(';');

  return lines.join('');
}

/**
 * Generate SQLite column definition
 */
function generateSQLiteColumn(column: Column, indentation: string, primaryKey?: { columns: string[] }): string {
  const sqliteType = normalizedTypeToSQLite(column);
  let def = `${indentation}${column.name} ${sqliteType}`;

  const isPrimaryKey = primaryKey?.columns.length === 1 && primaryKey.columns[0] === column.name;

  // PRIMARY KEY (for single-column primary keys)
  if (isPrimaryKey) {
    def += ' PRIMARY KEY';

    // AUTOINCREMENT (only for INTEGER PRIMARY KEY)
    if (column.autoIncrement && sqliteType === 'INTEGER') {
      def += ' AUTOINCREMENT';
    }
  }

  // NOT NULL
  if (!column.nullable && !isPrimaryKey) {
    def += ' NOT NULL';
  }

  // DEFAULT
  if (column.defaultValue !== undefined) {
    if (typeof column.defaultValue === 'string') {
      const upper = column.defaultValue.toUpperCase();
      if (upper === 'CURRENT_TIMESTAMP' || upper === 'NULL') {
        def += ` DEFAULT ${upper}`;
      } else {
        def += ` DEFAULT '${column.defaultValue}'`;
      }
    } else if (typeof column.defaultValue === 'boolean') {
      def += ` DEFAULT ${column.defaultValue ? 1 : 0}`;
    } else {
      def += ` DEFAULT ${column.defaultValue}`;
    }
  }

  // UNIQUE
  if (column.unique && !isPrimaryKey) {
    def += ' UNIQUE';
  }

  return def;
}

/**
 * Generate SQLite foreign key definition
 */
function generateSQLiteForeignKey(fk: ForeignKey, indentation: string): string {
  const cols = fk.columns.join(', ');
  const refCols = fk.referencedColumns.join(', ');

  let def = `${indentation}FOREIGN KEY (${cols}) REFERENCES ${fk.referencedTable}(${refCols})`;

  if (fk.onDelete) {
    def += ` ON DELETE ${fk.onDelete}`;
  }

  if (fk.onUpdate) {
    def += ` ON UPDATE ${fk.onUpdate}`;
  }

  return def;
}

/**
 * Generate SQLite indexes
 */
function generateSQLiteIndexes(table: Table): string[] {
  const statements: string[] = [];

  // Create indexes for foreign keys
  for (const fk of table.foreignKeys) {
    const indexName = `idx_${table.name}_${fk.columns.join('_')}`;
    const cols = fk.columns.join(', ');
    statements.push(`CREATE INDEX ${indexName} ON ${table.name} (${cols});`);
  }

  // Create other indexes
  for (const index of table.indexes) {
    const unique = index.unique ? 'UNIQUE ' : '';
    const cols = index.columns.join(', ');
    statements.push(`CREATE ${unique}INDEX ${index.name} ON ${table.name} (${cols});`);
  }

  return statements;
}

/**
 * Map normalized type to SQLite type
 */
function normalizedTypeToSQLite(column: Column): string {
  const typeMap: Record<string, string> = {
    string: 'TEXT',
    text: 'TEXT',
    integer: 'INTEGER',
    bigint: 'INTEGER',
    decimal: 'REAL',
    float: 'REAL',
    double: 'REAL',
    boolean: 'INTEGER',
    date: 'TEXT',
    datetime: 'TEXT',
    timestamp: 'TEXT',
    time: 'TEXT',
    blob: 'BLOB',
    json: 'TEXT',
    uuid: 'TEXT',
    enum: 'TEXT',
  };

  return typeMap[column.type] || 'TEXT';
}
