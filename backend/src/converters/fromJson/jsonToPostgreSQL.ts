/**
 * Phase 2: Convert standardized JSON schema to PostgreSQL DDL
 */

import { StandardizedSchema, Table, Column, ForeignKey } from '../../schema_parser/types';
import { PostgreSQLOptions } from './types';
import logger from '../../utils/logger';

/**
 * Convert standardized JSON schema to PostgreSQL DDL
 */
export function jsonToPostgreSQL(schema: StandardizedSchema, options: PostgreSQLOptions = {}): string {
  const {
    includeDropStatements = false,
    includeIfNotExists = true,
    indentation = '  ',
    includeComments = true,
    useSerial = true,
  } = options;

  logger.info('Converting standardized JSON to PostgreSQL DDL');

  const statements: string[] = [];

  // Header
  if (includeComments) {
    statements.push('-- PostgreSQL Schema Generated by TurboDbx');
    statements.push(`-- Source: ${schema.metadata.sourceType}`);
    statements.push(`-- Generated: ${new Date().toISOString()}`);
    statements.push('');
  }

  // Generate CREATE TABLE statements
  for (const table of schema.tables) {
    if (includeDropStatements) {
      statements.push(`DROP TABLE IF EXISTS "${table.name}" CASCADE;`);
      statements.push('');
    }

    statements.push(generatePostgreSQLCreateTable(table, {
      includeIfNotExists,
      indentation,
      useSerial,
    }));
    statements.push('');
  }

  logger.info(`Generated PostgreSQL DDL with ${schema.tables.length} tables`);

  return statements.join('\n');
}

/**
 * Generate PostgreSQL CREATE TABLE statement
 */
function generatePostgreSQLCreateTable(
  table: Table,
  options: {
    includeIfNotExists: boolean;
    indentation: string;
    useSerial: boolean;
  }
): string {
  const { includeIfNotExists, indentation, useSerial } = options;
  const lines: string[] = [];

  // CREATE TABLE
  const ifNotExists = includeIfNotExists ? 'IF NOT EXISTS ' : '';
  lines.push(`CREATE TABLE ${ifNotExists}"${table.name}" (`);

  // Columns
  const columnDefs = table.columns.map(col => generatePostgreSQLColumn(col, indentation, table.primaryKey, useSerial));
  lines.push(columnDefs.join(',\n'));

  // Primary Key
  if (table.primaryKey && table.primaryKey.columns.length > 0) {
    const pkCols = table.primaryKey.columns.map(c => `"${c}"`).join(', ');
    lines.push(`,\n${indentation}PRIMARY KEY (${pkCols})`);
  }

  // Foreign Keys
  for (const fk of table.foreignKeys) {
    lines.push(`,\n${generatePostgreSQLForeignKey(fk, indentation)}`);
  }

  // Unique constraints
  for (const index of table.indexes.filter(idx => idx.unique)) {
    const cols = index.columns.map(c => `"${c}"`).join(', ');
    lines.push(`,\n${indentation}UNIQUE (${cols})`);
  }

  lines.push('\n);');

  // Regular indexes (non-unique)
  const regularIndexes = table.indexes.filter(idx => !idx.unique);
  if (regularIndexes.length > 0) {
    lines.push('\n');
    for (const index of regularIndexes) {
      const cols = index.columns.map(c => `"${c}"`).join(', ');
      lines.push(`CREATE INDEX "${index.name}" ON "${table.name}" (${cols});`);
    }
  }

  return lines.join('');
}

/**
 * Generate PostgreSQL column definition
 */
function generatePostgreSQLColumn(
  column: Column,
  indentation: string,
  primaryKey: { columns: string[] } | undefined,
  useSerial: boolean
): string {
  const isPrimaryKey = primaryKey?.columns.length === 1 && primaryKey.columns[0] === column.name;

  // Use SERIAL for auto-increment primary keys
  let type = normalizedTypeToPostgreSQL(column);
  if (column.autoIncrement && isPrimaryKey && useSerial) {
    type = column.type === 'bigint' ? 'BIGSERIAL' : 'SERIAL';
  }

  let def = `${indentation}"${column.name}" ${type}`;

  // NOT NULL
  if (!column.nullable) {
    def += ' NOT NULL';
  }

  // DEFAULT
  if (column.defaultValue !== undefined && !column.autoIncrement) {
    if (typeof column.defaultValue === 'string') {
      const upper = column.defaultValue.toUpperCase();
      if (upper === 'CURRENT_TIMESTAMP' || upper === 'NULL') {
        def += ` DEFAULT ${upper}`;
      } else {
        def += ` DEFAULT '${column.defaultValue}'`;
      }
    } else if (typeof column.defaultValue === 'boolean') {
      def += ` DEFAULT ${column.defaultValue}`;
    } else {
      def += ` DEFAULT ${column.defaultValue}`;
    }
  }

  return def;
}

/**
 * Generate PostgreSQL foreign key definition
 */
function generatePostgreSQLForeignKey(fk: ForeignKey, indentation: string): string {
  const cols = fk.columns.map(c => `"${c}"`).join(', ');
  const refCols = fk.referencedColumns.map(c => `"${c}"`).join(', ');

  let def = `${indentation}FOREIGN KEY (${cols}) REFERENCES "${fk.referencedTable}"(${refCols})`;

  if (fk.onDelete) {
    def += ` ON DELETE ${fk.onDelete}`;
  }

  if (fk.onUpdate) {
    def += ` ON UPDATE ${fk.onUpdate}`;
  }

  return def;
}

/**
 * Map normalized type to PostgreSQL type
 */
function normalizedTypeToPostgreSQL(column: Column): string {
  const typeMap: Record<string, string> = {
    string: column.length ? `VARCHAR(${column.length})` : 'VARCHAR(255)',
    text: 'TEXT',
    integer: 'INTEGER',
    bigint: 'BIGINT',
    decimal: column.precision ? `DECIMAL(${column.precision},${column.scale || 2})` : 'DECIMAL(10,2)',
    float: 'REAL',
    double: 'DOUBLE PRECISION',
    boolean: 'BOOLEAN',
    date: 'DATE',
    datetime: 'TIMESTAMP',
    timestamp: 'TIMESTAMP',
    time: 'TIME',
    blob: 'BYTEA',
    json: 'JSONB',
    uuid: 'UUID',
    enum: column.enum ? `VARCHAR(50) CHECK ("${column.name}" IN ('${column.enum.join("','")}'))` : 'VARCHAR(255)',
  };

  return typeMap[column.type] || 'VARCHAR(255)';
}
