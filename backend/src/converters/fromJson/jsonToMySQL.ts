/**
 * Phase 2: Convert standardized JSON schema to MySQL DDL
 */

import { StandardizedSchema, Table, Column, ForeignKey } from '../../schema_parser/types';
import { MySQLOptions } from './types';
import logger from '../../utils/logger';

/**
 * Convert standardized JSON schema to MySQL DDL
 */
export function jsonToMySQL(schema: StandardizedSchema, options: MySQLOptions = {}): string {
  const {
    includeDropStatements = false,
    includeIfNotExists = true,
    indentation = '  ',
    includeComments = true,
    engine = 'InnoDB',
    charset = 'utf8mb4',
    collation = 'utf8mb4_unicode_ci',
  } = options;

  logger.info('Converting standardized JSON to MySQL DDL');

  const statements: string[] = [];

  // Header
  if (includeComments) {
    statements.push('-- MySQL Schema Generated by TurboDbx');
    statements.push(`-- Source: ${schema.metadata.sourceType}`);
    statements.push(`-- Generated: ${new Date().toISOString()}`);
    statements.push('');
  }

  // Generate CREATE TABLE statements
  for (const table of schema.tables) {
    if (includeDropStatements) {
      statements.push(`DROP TABLE IF EXISTS \`${table.name}\`;`);
      statements.push('');
    }

    statements.push(generateMySQLCreateTable(table, {
      includeIfNotExists,
      indentation,
      engine,
      charset,
      collation,
    }));
    statements.push('');
  }

  logger.info(`Generated MySQL DDL with ${schema.tables.length} tables`);

  return statements.join('\n');
}

/**
 * Generate MySQL CREATE TABLE statement
 */
function generateMySQLCreateTable(
  table: Table,
  options: {
    includeIfNotExists: boolean;
    indentation: string;
    engine: string;
    charset: string;
    collation: string;
  }
): string {
  const { includeIfNotExists, indentation, engine, charset, collation } = options;
  const lines: string[] = [];

  // CREATE TABLE
  const ifNotExists = includeIfNotExists ? 'IF NOT EXISTS ' : '';
  lines.push(`CREATE TABLE ${ifNotExists}\`${table.name}\` (`);

  // Columns
  const columnDefs = table.columns.map(col => generateMySQLColumn(col, indentation, table.primaryKey));
  lines.push(columnDefs.join(',\n'));

  // Primary Key
  if (table.primaryKey && table.primaryKey.columns.length > 0) {
    const pkCols = table.primaryKey.columns.map(c => `\`${c}\``).join(', ');
    lines.push(`,\n${indentation}PRIMARY KEY (${pkCols})`);
  }

  // Foreign Keys
  for (const fk of table.foreignKeys) {
    lines.push(`,\n${generateMySQLForeignKey(fk, indentation)}`);
  }

  // Indexes
  for (const index of table.indexes) {
    const unique = index.unique ? 'UNIQUE ' : '';
    const cols = index.columns.map(c => `\`${c}\``).join(', ');
    lines.push(`,\n${indentation}${unique}KEY \`${index.name}\` (${cols})`);
  }

  lines.push(`\n) ENGINE=${engine} DEFAULT CHARSET=${charset} COLLATE=${collation};`);

  return lines.join('');
}

/**
 * Generate MySQL column definition
 */
function generateMySQLColumn(column: Column, indentation: string, primaryKey?: { columns: string[] }): string {
  let def = `${indentation}\`${column.name}\` ${normalizedTypeToMySQL(column)}`;

  const isPrimaryKey = primaryKey?.columns.length === 1 && primaryKey.columns[0] === column.name;

  // AUTO_INCREMENT
  if (column.autoIncrement) {
    def += ' AUTO_INCREMENT';
  }

  // NOT NULL
  if (!column.nullable) {
    def += ' NOT NULL';
  }

  // DEFAULT
  if (column.defaultValue !== undefined) {
    if (typeof column.defaultValue === 'string') {
      const upper = column.defaultValue.toUpperCase();
      if (upper === 'CURRENT_TIMESTAMP' || upper === 'NULL') {
        def += ` DEFAULT ${upper}`;
      } else {
        def += ` DEFAULT '${column.defaultValue}'`;
      }
    } else {
      def += ` DEFAULT ${column.defaultValue}`;
    }
  }

  // UNIQUE
  if (column.unique && !isPrimaryKey) {
    def += ' UNIQUE';
  }

  // COMMENT
  if (column.comment) {
    def += ` COMMENT '${column.comment.replace(/'/g, "''")}'`;
  }

  return def;
}

/**
 * Generate MySQL foreign key definition
 */
function generateMySQLForeignKey(fk: ForeignKey, indentation: string): string {
  const cols = fk.columns.map(c => `\`${c}\``).join(', ');
  const refCols = fk.referencedColumns.map(c => `\`${c}\``).join(', ');

  let def = `${indentation}FOREIGN KEY (${cols}) REFERENCES \`${fk.referencedTable}\`(${refCols})`;

  if (fk.onDelete) {
    def += ` ON DELETE ${fk.onDelete}`;
  }

  if (fk.onUpdate) {
    def += ` ON UPDATE ${fk.onUpdate}`;
  }

  return def;
}

/**
 * Map normalized type to MySQL type
 */
function normalizedTypeToMySQL(column: Column): string {
  const typeMap: Record<string, string> = {
    string: column.length ? `VARCHAR(${column.length})` : 'VARCHAR(255)',
    text: 'TEXT',
    integer: 'INT',
    bigint: 'BIGINT',
    decimal: column.precision ? `DECIMAL(${column.precision},${column.scale || 2})` : 'DECIMAL(10,2)',
    float: 'FLOAT',
    double: 'DOUBLE',
    boolean: 'BOOLEAN',
    date: 'DATE',
    datetime: 'DATETIME',
    timestamp: 'TIMESTAMP',
    time: 'TIME',
    blob: 'BLOB',
    json: 'JSON',
    uuid: 'VARCHAR(36)',
    enum: column.enum ? `ENUM('${column.enum.join("','")}')` : 'VARCHAR(255)',
  };

  return typeMap[column.type] || 'VARCHAR(255)';
}
